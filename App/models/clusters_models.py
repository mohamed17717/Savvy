import json
import numpy as np

from django.db import models
from django.db.models import Sum
from django.contrib.auth import get_user_model
from django.shortcuts import reverse
from django.core.validators import FileExtensionValidator
from django.core.files.base import ContentFile
from django.contrib.postgres.aggregates import ArrayAgg

from common.utils.file_utils import random_filename


class Cluster(models.Model):
    """Generated by ML model or Equation or whatever
    Grouping bookmarks blindly without knowing the relation
    """

    # Relations
    user = models.ForeignKey(
        get_user_model(), on_delete=models.CASCADE, related_name='clusters'
    )
    bookmarks = models.ManyToManyField('App.Bookmark', related_name='clusters')
    bookmarks_count = models.PositiveSmallIntegerField(default=0)

    # Required , can be null and user can set it
    # if it null then it will be calculated using the highest tag
    name = models.CharField(max_length=128)
    correlation = models.FloatField(default=0.0)

    # Timing
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    @property
    def tags(self):
        tags = Tag.objects.filter(
            bookmarks__in=self.bookmarks.all()).distinct()
        return tags

    @property
    def general_words_vector(self):
        general_vector = {}
        for b in self.bookmarks.all():
            for word, weight in b.important_words.items():
                general_vector.setdefault(word, 0)
                general_vector[word] += weight

        return general_vector

    def get_absolute_url(self):
        return reverse("app:cluster-detail", kwargs={"pk": self.pk})


class Tag(models.Model):
    '''Tag is a stored operation for words table
    weight = sum([word.weight for word in words])
    name = word.name
    bookmarks = bookmarks that related to this word
    alias_name = name by the user
    '''
    user = models.ForeignKey(
        get_user_model(), on_delete=models.CASCADE, related_name='tags'
    )
    # TODO bookmarks should be RCs
    bookmarks = models.ManyToManyField(
        'App.Bookmark', blank=True, related_name='tags')

    # Required
    name = models.CharField(max_length=128)

    # Optional
    alias_name = models.CharField(max_length=128, blank=True, null=True)

    # Computed
    weight = models.PositiveSmallIntegerField(default=0)

    # Timing
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('user', 'name')

    def __str__(self):
        return f'{self.pk} - {self.name} = {self.weight}'

    def get_absolute_url(self):
        return reverse("app:tag-detail", kwargs={"pk": self.pk})

    @classmethod
    def update_tags_with_new_bookmarks(cls, bookmarks_ids: list[int]):
        from App.models import WordWeight, Bookmark

        # make sure this bookmarks has no tags
        if cls.objects.filter(bookmarks__in=bookmarks_ids).exists():
            raise ValueError('Bookmarks has tags')

        # get words
        words_qs = (WordWeight.objects
                    .filter(bookmark_id__in=bookmarks_ids, important=True)
                    .values('word')
                    .annotate(
                        total_weight=Sum('weight'),
                        bookmark_ids=ArrayAgg('bookmark')
                    ))
        words = set(words_qs.values_list('word', flat=True))
        words_map = {w['word']: w for w in words_qs}

        # Update existing tags
        existing_tags = cls.objects.filter(name__in=words)
        for tag in existing_tags:
            tag.weight += words_map[tag.name]['total_weight']
        cls.objects.bulk_update(existing_tags, ['weight'], batch_size=250)

        # Create new tags
        existing_tag_names = set(existing_tags.values_list('name', flat=True))
        new_tag_names = words - existing_tag_names

        user = Bookmark.objects.filter(pk__in=bookmarks_ids).first().user

        new_tags = [
            cls(name=name, weight=words_map[name]['total_weight'], user=user)
            for name in new_tag_names
        ]
        new_tags = cls.objects.bulk_create(new_tags, batch_size=250)

        # Create relation between tags and bookmarks
        all_tags = [*existing_tags, *new_tags]
        relation_model = cls.bookmarks.through
        relations = []

        for tag in all_tags:
            relations.extend([
                relation_model(bookmark_id=bookmark_id, tag_id=tag.pk)
                for bookmark_id in words_map[tag.name]['bookmark_ids']
            ])

        relation_model.objects.bulk_create(relations, batch_size=250)
        return len(all_tags)


class SimilarityMatrix(models.Model):
    user = models.OneToOneField(
        get_user_model(), on_delete=models.CASCADE, related_name='similarity_matrix'
    )

    bookmarks_ids = models.JSONField(default=list, blank=True)
    file = models.FileField(
        upload_to='similarity-matrix/',
        validators=[FileExtensionValidator(['json'])])

    def save(self, *args, **kwargs):
        self.full_clean()
        return super().save(*args, **kwargs)  # Call the real save() method

    @property
    def bookmarks(self):
        # from App.models import Bookmark
        # process_status=Bookmark.ProcessStatus.CLUSTERED.value
        return self.user.bookmarks.filter(pk__in=self.bookmarks_ids)

    @property
    def to_type(self):
        from . import WordWeight
        from App.types import SimilarityMatrixType

        document_ids, vectors = WordWeight.word_vectors(self.bookmarks)
        if not document_ids or not vectors:
            return None

        return SimilarityMatrixType.load(
            vectors=vectors,
            document_ids=document_ids,
            path=self.file.path
        )

    def update_matrix(self, similarity_matrix: np.ndarray, bookmarks_ids: list):
        with self.file.open('w') as f:
            f.write(json.dumps(similarity_matrix.tolist()))

        self.bookmarks_ids = bookmarks_ids
        self.save(update_fields=['bookmarks_ids'])

        return True

    @classmethod
    def get_object(cls, user):
        try:
            return cls.objects.get(user=user)
        except cls.DoesNotExist:
            path = random_filename(cls.file.field.upload_to, 'json')
            filename = path.split('/')[-1]
            content_file = ContentFile(b"{}", name=filename)

            return cls.objects.create(user=user, file=content_file)
